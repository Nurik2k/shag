1. Что такое многопоточность?
В компьютерной архитектуре Многопоточность - способность центрального процессора (CPU) или одного ядра в многоядерном процессоре одновременно выполнять несколько процессов или потоков, соответствующим образом поддерживаемых операционной системой. Этот подход отличается от многопроцессорности, так как многопоточность процессов и потоков совместно использует ресурсы одного или нескольких ядер: вычислительных блоков, кэш-памяти ЦПУ или буфера перевода с преобразованием (TLB).

Использование многопоточности
Многопоточность - это способ ввести параллелизм в системе или программе. Таким образом, вы можете использовать его везде, где видите параллельные пути (где два потока не зависят от результата друг друга), чтобы сделать его быстрым и простым.
Например:
- Обработка больших данных, где они могут быть разделены на части и выполнены с использованием нескольких потоков.
- Приложения, которые включают такой механизм, как проверка и сохранение, создание и использование, чтение и проверка, выполняются в несколько потоков. Несколько примеров таких приложений - онлайн-банкинг, пополнение счета и т. Д.
- Его можно использовать для создания игр, в которых разные элементы работают в разных потоках.
- В Android он используется для обращения к API, работающим в фоновом потоке, чтобы сохранить приложение от остановки.
- В веб-приложениях он используется, когда вы хотите, чтобы ваше приложение получало асинхронные вызовы и выполняло асинхронно.

Преимущества многопоточности
<Экономичный>: он экономичен, поскольку они используют одни и те же ресурсы процессора. Создание потоков занимает меньше времени.
<Совместное использование ресурсов>: позволяет потокам совместно использовать ресурсы, такие как данные, память, файлы и т. Д. Следовательно, приложение может иметь несколько потоков в одном и том же адресном пространстве.
<Отзывчивость>. Повышает скорость отклика пользователя, поскольку позволяет программе продолжать работу, даже если часть ее выполняет длительную операцию или заблокирована.
<Масштабируемость>: увеличивает параллелизм на нескольких процессорных машинах. Это повышает производительность многопроцессорных машин.
 
Это делает использование ресурсов процессора лучше.
---
Потоки выполнения отличаются от традиционных процессов многозадачной операционной системы тем, что:
- процессы, как правило, независимы, тогда как потоки выполнения существуют как составные элементы процессов
- процессы несут значительно больше информации о состоянии, тогда как несколько потоков выполнения внутри процесса совместно используют информацию о состоянии, а также память и другие вычислительные ресурсы
- процессы имеют отдельные адресные пространства, тогда как потоки выполнения совместно используют их адресное пространство
процессы взаимодействуют только через предоставляемые системой механизмы связей между процессами
переключение контекста между потоками выполнения в одном процессе, как правило, быстрее, чем переключение контекста между процессами.

---
2. Общие сведения о потоках:
- что такое поток?
Поток выполнения (тред; от англ. thread — нить) — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы. Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток выполнения находится внутри процесса. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют последовательность инструкций процесса (его код) и его контекст — значения переменных (регистров процессора и стека вызовов), которые они имеют в любой момент времени.

3. Потоки в .NET Framework:
https://docs.microsoft.com/ru-ru/dotnet/standard/threading/
https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-5.0

- Создание потока
Создание нового объекта Thread приводит к созданию нового управляемого потока. Класс Thread имеет конструкторы, которые принимают делегат ThreadStart или ParameterizedThreadStart. Этот делегат инкапсулирует метод, который вызывается новым потоком при вызове метода Start. Повторный вызов Start приводит к созданию исключения ThreadStateException.
Метод Start завершается немедленно, часто даже до запуска нового потока. Вы можете использовать свойства ThreadState и IsAlive, чтобы определить состояние потока в настоящий момент, но эти свойства ни в коем случае нельзя использовать для синхронизации действий потоков.

- Приостановка и прерывание потоков
Метод Thread.Sleep
Вызов метода Thread.Sleep приводит к немедленной блокировке текущего потока на определенное количество миллисекунд, переданное этому методу, вследствие чего остаток среза времени передается другому потоку. По истечении этого интервала времени спящий поток возобновляет выполнение.

- Прерывание потоков
Ожидающий поток можно прервать, вызвав метод Thread.Interrupt для заблокированного потока. Это действие создает исключение ThreadInterruptedException, которое выводит поток из вызова блокировки. Поток должен перехватить исключение ThreadInterruptedException и выполнить соответствующие действия для продолжения работы. Если поток пропускает исключение, среда выполнения перехватывает его и останавливает поток.

- Удаление потоков
Модель совместной отмены используется для остановки потока. Иногда выполнить совместную отмену потока невозможно, так как он выполняет код сторонних производителей, не поддерживающий такую отмену. Метод Thread.Abort в .NET Framework можно использовать для принудительного завершения управляемого потока. При вызове Abort общеязыковая среда выполнения создает в целевом потоке исключение ThreadAbortException, которое целевой поток может перехватить. Для получения дополнительной информации см. Thread.Abort. Метод Thread.Abort не поддерживается в .NET 5 (включая .NET Core) и более поздних версий. Если необходимо принудительно завершить выполнение кода сторонних производителей в .NET 5 или более поздней версии, запустите его в отдельном процессе и воспользуйтесь Process.Kill.

---
4. Потоки в Win API:
https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads
https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/

---
5. Асинхронный вызов методов.

using System;
using System.IO;
using System.Threading;

namespace CSharp
{
    class Program
    {
        class SystemLog 
        {
            private string _filename;
            public SystemLog(string fn)
            {
                _filename = fn;
            }
            public void WriteLogAsync(string str)
            {
                Thread thread = new Thread(new ThreadStart(() => {
                    using (StreamWriter writer = new StreamWriter(_filename))
                    {
                        writer.WriteLine(str);
                        Console.WriteLine("Write log.");
                    }
                }));
                thread.Start();
            }
        }
        static void Main(string[] args)
        {
            SystemLog log = new SystemLog("log.txt");

            log.WriteLogAsync("Test string.");

            Console.WriteLine("Start sleep.");
            Thread.Sleep(10000);
            Console.WriteLine("End sleep.");
            Console.Read();
        }
    }
}

---
6. Использование таймеров обратного вызова.
https://docs.microsoft.com/en-us/dotnet/api/system.timers.timer?view=net-5.0

using System;
using System.Timers;

namespace CSharp
{
    class Program
    {
        private static System.Timers.Timer aTimer;
        public static void Main()
        {
            SetTimer();

            Console.WriteLine("\nPress the Enter key to exit the application...\n");
            Console.WriteLine("The application started at {0:HH:mm:ss.fff}", DateTime.Now);
            Console.ReadLine();
            aTimer.Stop();
            aTimer.Dispose();

            Console.WriteLine("Terminating the application...");
            Console.ReadKey();
        }

        private static void SetTimer()
        {
            // Create a timer with a two second interval.
            aTimer = new System.Timers.Timer(2000);
            // Hook up the Elapsed event for the timer. 
            aTimer.Elapsed += OnTimedEvent;
            aTimer.AutoReset = true;
            aTimer.Enabled = true;
        }

        private static void OnTimedEvent(Object source, ElapsedEventArgs e)
        {
            Console.WriteLine("The Elapsed event was raised at {0:HH:mm:ss.fff}",
                              e.SignalTime);
        }
    }
}

---
7. Использование пула потоков.
https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace CSharp
{
    class Program
    {
        class SystemLog 
        {
            private string _filename;
            public SystemLog(string fn)
            {
                _filename = fn;
            }
            public void WriteLogAsync(string str)
            {
                Task task = new Task(() => {
                    using (StreamWriter writer = new StreamWriter(_filename))
                    {
                        writer.WriteLine(str);
                        Console.WriteLine("Write log.");
                    }
                });
                task.Start();
            }
        }
        static void Main(string[] args)
        {
            SystemLog log = new SystemLog("log.txt");

            log.WriteLogAsync("Test string.");

            Console.WriteLine("Start sleep.");
            Thread.Sleep(10000);
            Console.WriteLine("End sleep.");
            Console.Read();
        }
    }
}