1. Почему необходимо использовать унаследованный программный код.

https://docs.microsoft.com/ru-ru/dotnet/framework/interop/
Платформа .NET Framework обеспечивает взаимодействие с COM-компонентами, службами COM+, внешними библиотеками типов и многими службами операционной системы. Типы данных, подписи методов и механизмы обработки ошибок различны в управляемой и неуправляемой моделях объектов. Для упрощения взаимодействия между компонентами .NET Framework и неуправляемым программным кодом, а также для облегчения перехода от одной модели к другой среда CLR скрывает имеющиеся в этих объектных моделях различия от клиентов и серверов.

Код, выполняющийся под управлением среды выполнения, называется управляемым кодом. И наоборот, код, выполняемый вне среды выполнения, называется неуправляемым кодом. Примерами неуправляемого кода являются компоненты COM, интерфейсы ActiveX и функции Windows API.
---
https://docs.microsoft.com/ru-ru/windows/win32/system-services

В этом разделе содержится справочник по системным api и службам, предлагаемым Windows для классических приложений. К ним относятся общедоступные службы для:

Объектная модель компонента (COM).
Сжатие файлов.
Библиотеки динамической компоновки.
Управление памятью
Управление питанием.
Создание и координация нескольких потоков выполнения.
Разработка приложений служб.
Windows обмен сообщениями.
получение сведений о системе Windows.
API справки.
---
2. Пространство System.Runtime.InteropServices.
https://docs.microsoft.com/ru-ru/dotnet/api/system.runtime.interopservices?view=net-5.0
Предоставляет разнообразные члены, поддерживающие COM-взаимодействие и службы вызова платформы.

https://docs.microsoft.com/ru-ru/windows/win32/apiindex/windows-api-list?redirectedfrom=MSDN
Приведен список справочных материалов по Windows прикладного программного интерфейса (API) для настольных и серверных приложений.

С помощью API Windows можно разрабатывать приложения, которые успешно выполняются во всех версиях Windows, при этом используя преимущества функций и возможностей, уникальных для каждой версии. (Обратите внимание, что раньше это называлось API Win32. имя Windows API более точно отражает его корни в 16-разрядной Windows и поддерживает 64-разрядную Windows.)

---
3 . Взаимодействие с модулями Dll:

[DllImport("user32.dll", CharSet = CharSet.Unicode)]
класс DllImportAttribute;

BestFitMapping -	Включает или отключает наиболее подходящее поведение сопоставления при преобразовании символов Юникода в символы ANSI.
CallingConvention -	Указывает соглашение о вызовах точки входа.
CharSet -		Указывает, как маршалировать строковые параметры для метода и изменять имя элемента управления.
EntryPoint -		Указывает имя или порядковый номер вызываемой точки входа DLL.
ExactSpelling -		Определяет, заставляет ли поле CharSet выполнять поиск в неуправляемой библиотеке DLL имен точек входа, отличных от указанного.
PreserveSig -		Указывает, транслируются ли неуправляемые методы с возвращаемыми значениями HRESULT напрямую или возвращаемые значения HRESULT автоматически преобразуются в исключения.
SetLastError -		Указывает, вызывает ли вызываемый объект функцию Windows API SetLastError перед возвратом из метода с атрибутами.
ThrowOnUnmappableChar -	Включает или отключает создание исключения для несопоставимого символа Unicode, который преобразован в ANSI "?" персонаж.

---
4. Пример использования 
namespace CSharp
{
    class Program
    {
        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);
        static void Main(string[] args)
        {
            MessageBox(new IntPtr(0), "Hello World!", "Hello Dialog", 0);
            Console.WriteLine("\n-< End >-");
            Console.ReadKey();
        }
    }
}

// [System.Windows.MessageBox]::Show('Hello')